---
title: OpenDAL RangeReader çš„å¥¥å¦™
date: 2022/12/16
description: è¯´äº†å¤šå°‘éäº†è¦ RTFSCï¼ŒRTFSC
tag: Rust, OpenDAL
author: Weny
---

import { Callout } from 'nextra/components'

## å‰æƒ…æè¦

æˆ‘ä»¬([GreptimeDB](https://github.com/greptimeTeam/greptimedb/))æŠŠ [OpenDAL](https://github.com/apache/incubator-opendal) ä½œä¸ºç»Ÿä¸€çš„æ•°æ®è®¿é—®å±‚ã€‚å‰æ®µæ—¶é—´åŒäº‹å‘Šè¯‰æˆ‘ï¼Œæ•°æ®åº“æ‰§è¡Œ `Copy From` è¯­å¥ä» S3 å¯¼å…¥ä¸€ä¸ª 800 KiB çš„ Parquet æ–‡ä»¶éœ€è¦ 10sï¼›ç»è¿‡äº†ä¸€äº›è°ƒæŸ¥ï¼Œè¯»äº†ä¸‹ç›¸å…³ Reader çš„æ–‡æ¡£å’Œå…·ä½“å®ç° ~~ï¼ˆæš´éœ²äº†ä¹‹å‰æ²¡æœ‰ RTFSC ğŸ¥²ï¼‰~~ï¼Œæœ¬æ–‡åšä¸€ä¸ªè®°å½•å’Œç®€å•çš„æ€»ç»“ã€‚

<Callout type="info" emoji="â„¹ï¸">
  æœ¬æ–‡æ¶‰åŠçš„ OpenDAL æºç  Commit: [6980cd1](https://github.com/apache/incubator-opendal/tree/6980cd15007c9a2ae8422cbc0750c818e178abf2)
</Callout>

## TL;DR

- OpenDAL `RangeReader` æ¯æ¬¡è°ƒç”¨ `read` æ–¹æ³•ï¼Œæ— è§†ç”¨æˆ· `buf` å¤§å°ï¼Œé»˜è®¤è¯»å– `[SeekPos, Size)` èŒƒå›´çš„æ‰€æœ‰å­—èŠ‚ã€‚ï¼ˆç›¸å…³ [issue](https://github.com/apache/incubator-opendal/issues/3747)ï¼‰
- `std::io::BufReader` å’Œ  `tokio::io::BufReader` éƒ½ä¼šåœ¨ `seek` åæ¸…é™¤å†…éƒ¨ `Buffer`ï¼Œå¦‚æœå¸Œæœ›ç»§ç»­è¯» `Buffer` å†…çš„å†…å®¹ï¼Œåº”è¯¥è°ƒç”¨ `seek_relative`ã€‚
- ä» S3 è¯»å–å…ƒä¿¡æ¯åœ¨å°¾éƒ¨æ–‡ä»¶æ ¼å¼ï¼Œå¯ä»¥è€ƒè™‘åŠ ä¸€å±‚ `Tailing Buffer` (å³ï¼Œä»»ä½•è½å…¥ç”¨æˆ·å®šä¹‰çš„ `Tailing Bytes` èŒƒå›´å†…çš„ `seek` çš„æ“ä½œï¼Œåªåœ¨ç¬¬ä¸€æ¬¡åŠ è½½å¹¶ç¼“å­˜ `Tailing Bytes`)ï¼Œä¸€äº›åœºæ™¯å¯ä»¥å‡å°‘ä¸€æ¬¡ S3 get è¯·æ±‚(è¿™ä¸ªæœ¬è´¨ä¸Šæ˜¯ä¸€ç§åˆ†å¼€è¯»å°¾éƒ¨å…ƒä¿¡æ¯çš„æ›¿æ¢æ–¹æ¡ˆ)ã€‚


## å…ˆæ¥èŠèŠè¯¥æ€ä¹ˆè¯» OpenDAL æºç ï¼Ÿ

å¦ç‡è¯´ï¼ŒOpenDAL çš„æºç æˆ‘ä¹Ÿæ˜¯æœ€è¿‘æ‰ç†æ¸…æ¥šå…¶è°ƒç”¨å…³ç³»ï¼Œä¹‹å‰éƒ½æ˜¯ä¸€çŸ¥åŠè§£ã€‚


<CH.Scrollycoding>
### ä» Operator å¼€å§‹

æˆ‘ä»¬æ‰€æœ‰çš„ IO æ“ä½œéƒ½æ˜¯å›´ç»•ç€ `Operator` å±•å¼€çš„ï¼Œå…ˆæ¥çœ‹ä¸‹ `Operator` æ˜¯æ€ä¹ˆæ„å»ºçš„ã€‚
ä»¥ `main.rs` ä¸ºä¾‹ï¼Œé¦–å…ˆæˆ‘ä»¬[åœ¨ L7 åˆ›å»ºäº†ä¸€ä¸ªåŸºäºæ–‡ä»¶ç³»ç»Ÿçš„ `Backend Builder`](focus://7)ï¼›
[åœ¨ L13 å°†å…¶æ„å»ºä¸º `accessor`ï¼ˆå®ç°äº† `Accessor` trait)](focus://13)ï¼›
[L14 æˆ‘ä»¬å°†è¯¥ `accessor` ä¼ å…¥äº† `OperatorBuilder::new`ï¼Œæœ€åè°ƒç”¨äº† `finish`ã€‚](focus://14) 


<Callout type="info" emoji="â„¹ï¸">
  OpenDAL é€šè¿‡ `Accessor` trait ç»Ÿä¸€äº†ä¸åŒå­˜å‚¨åç«¯(Backend)çš„è¡Œä¸ºï¼Œå¹¶å‘ä¸Šå±‚æš´éœ²ç»Ÿä¸€çš„ IO æ¥å£ï¼Œä¾‹å¦‚ `create_dir`, `read`, `write` ç­‰ã€‚
</Callout>


```rust main.rs focus=7,13:14
use opendal::services::Fs;
use opendal::Operator;

#[tokio::main]
async fn main() -> Result<()> {
    // Create fs backend builder.
    let mut builder = Fs::default();
    // Set the root for fs, all operations will happen under this root.
    //
    // NOTE: the root must be absolute path.
    builder.root("/tmp");

    let accessor = builder.build()?;
    let op: Operator = OperatorBuilder::new(accessor)?.finish();

    Ok(())
}
```

---

### åœ¨ OperatorBuilder::new å‘ç”Ÿäº†ä»€ä¹ˆ
æˆ‘ä»¬ä¼ å…¥çš„ `accessor` åœ¨è°ƒç”¨ `new` æ—¶ï¼Œ[è¢«è¿½åŠ äº†ä¸¤å±‚ `Layer`](focus://6:8)ï¼Œå¹¶åœ¨è°ƒç”¨ `finish` æ—¶ï¼Œ[è¢«è¿½åŠ äº†ä¸€å±‚å†…éƒ¨ `Layer`](focus://15:16)ã€‚


```rust src/types/operator/builder.rs focus=6:8,15:16
impl<A: Accessor> OperatorBuilder<A> {
    /// Create a new operator builder.
    #[allow(clippy::new_ret_no_self)]
    pub fn new(accessor: A) -> OperatorBuilder<impl Accessor> {
        // Make sure error context layer has been attached.
        OperatorBuilder { accessor }
            .layer(ErrorContextLayer)
            .layer(CompleteLayer)
    }

    ...
    
    /// Finish the building to construct an Operator.
    pub fn finish(self) -> Operator {
        let ob = self.layer(TypeEraseLayer);
        Operator::from_inner(Arc::new(ob.accessor) as FusedAccessor)
    }
}
```

è¿½åŠ  `Layer` åï¼Œå½“æˆ‘ä»¬è°ƒç”¨ `Operator` æš´éœ²å‡ºæ¥çš„æ¥å£æ—¶ï¼Œè°ƒç”¨ä¼šä»æœ€å¤–å±‚ `CompleteLayer`å¼€å§‹ï¼Œå¹¶æœ€ç»ˆæŠµè¾¾æœ€å†…å±‚ `FsAccessor`ã€‚

```
FsAccessor
ErrorContextLayer
CompleteLayer
^
|
| Invoking (`read`, `reader_with`, `stat`...)
```

<Callout type="info" emoji="ğŸ¤£">
  **TL;DR** å…¶å®è¯´äº†åŠå¤©ï¼Œæƒ³å¼ºè°ƒä¸€ä¸‹ï¼Œä»£ç åº”è¯¥ä» `CompleteLayer` å¼€å§‹è¯»ï¼ˆå¤§é›¾
</Callout>


</CH.Scrollycoding>

## æˆ‘ä»¬çš„ä¸Šä¸‹æ–‡
è¿™é‡Œæˆ‘ä»¬è¡¥å……ä¸€äº›å¿…è¦çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œä»¥ä¾¿ç†è§£åæ–‡å†…å®¹ã€‚

### LruCacheLayer
ç›®å‰ï¼Œåœ¨æŸ¥è¯¢åœºæ™¯ï¼Œæˆ‘ä»¬è¿½åŠ äº†ä¸€å±‚ `LruCacheLayer`ï¼Œé‚£ä¹ˆæˆ‘ä»¬ `Operator` å°±å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

```
S3Accessor                FsAccessor
ErrorContextLayer         ErrorContextLayer
CompleteLayer             CompleteLayer
    â–²                         â–²  â”‚
    â”‚                         â”‚  â”‚
    â”‚`inner`           `cache`â”‚  â”‚
    â”‚                         â”‚  â”‚
    â”‚                         â”‚  â”‚
    â”‚                         â”‚  â”‚
    â””â”€â”€â”€â”€â”€ LruCacheLayer â”€â”€â”€â”€â”€â”˜  â”‚
                 â–²               â”‚      
                 â”‚               â”‚
                 â”‚               â”‚ 
                 â”‚               â–¼
                 â”‚               FileReader::new(oio::TokioReader<tokio::fs::File>) 
                 â”‚ 
                 Invoking(`reader`, `reader_with`)  
      
```

<CH.Section>

ä»¥ `read` æ¥å£ä¸ºä¾‹ï¼Œ`LruCacheLayer`ä¼šå°† S3 çš„æ–‡ä»¶ç¼“å­˜åˆ°æ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œ
[å¹¶å‘ä¸Šå±‚è¿”å›ç¼“å­˜çš„åŸºäºæ–‡ä»¶ç³»ç»Ÿçš„ `Box<dyn oio::Read>`(`FileReader::new(oio::TokioReader<tokio::fs::File>)`)](focus://10:12)ï¼›
å½“ç„¶å¦‚æœè¯»å–çš„æ–‡ä»¶ä¸å­˜åœ¨äºç¼“å­˜æ—¶ï¼Œ[åˆ™å…ˆå…¨é‡ä» S3 åŠ è½½æ–‡ä»¶è‡³æœ¬åœ°çš„æ–‡ä»¶ç³»ç»Ÿä¸­](focus://13:15)ï¼ˆ**è¿™é‡Œæœªæ¥æˆ–è®¸å¯ä»¥åšä¸€ä¸ªå¹¶è¡ŒåŠ è½½çš„ä¼˜åŒ–**ï¼‰ã€‚

```rust
struct LruCacheLayer {
  inner: Operator, // S3Backend
  cache: Operator, // FsBackend
  index: CacheIndex
}

impl LayeredAccessor for LruCacheLayer {
  ...
  async fn read(&self, path: &str, args: OpRead) -> Result<(RpRead, Self::Reader)> {
        if self.index.hit(path, args) {
          // Returns `Box<dyn oio::Read>`
          self.cache.read(path, args).await 
        } else {
          // Fetches cache and stores...
        }
  }
  ...
}
```

</CH.Section>


### Copy From çš„åœºæ™¯

åœ¨ `Copy From` åœºæ™¯ï¼Œæˆ‘å¹¶æ²¡æœ‰åŠ è¿™ä¸€å±‚ `LruCacheLayer`ã€‚é‚£ä¹ˆæˆ‘ä»¬ `Operator` å°±å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š
```
S3Accessor
ErrorContextLayer
CompleteLayer
   â–²    â”‚
   â”‚    â”‚
   â”‚    â”‚
   â”‚    â–¼ 
   â”‚    RangeReader::new(IncomingAsyncBody)
   â”‚
   Invoking (`reader`, `reader_with`)
```
å…³äºä¸ºä»€ä¹ˆæ²¡æœ‰åŠ  `Cache` åŸå› å¦‚ä¸‹ï¼š
1. é”™è¯¯ç†è§£ OpenDAL `Reader` å·¥ä½œæ–¹å¼ï¼Œå½“æ—¶ä»¥ä¸º `Reader` åœ¨å…¶ç”Ÿå‘½å‘¨æœŸå†…ï¼Œåœ¨å…¶å…¨é‡è¯»å– S3 æ–‡ä»¶åï¼Œè°ƒç”¨å…¶ `seek`, `read` æ–¹æ³•ä¸éœ€è¦é¢å¤–çš„ S3 get è¯·æ±‚ã€‚
2. `Copy From` çš„æ–‡ä»¶é€šå¸¸åªä¼šè¢«è¯»å–ä¸€æ¬¡ï¼Œå½“æ—¶è®¤ä¸ºåŠ ä¸€å±‚ `Cache` å¹¶æ²¡æœ‰ä¸å¤§ã€‚

æ€»ä¹‹å°±æ˜¯æˆ‘å½“æ—¶å†™çš„ä¸è¡ŒğŸ¥¹

## åœ¨ä½¿ç”¨ RangeReader æ—¶é‡åˆ°çš„é—®é¢˜

<CH.Scrollycoding>
### ä»æ„å»º ParquetRecordBatchStream è¯´èµ·
åœ¨ `Copy From` ä¸­ï¼Œæˆ‘ä»¬æ‹¿åˆ°æ–‡ä»¶ä¿¡æ¯åï¼Œ[é¦–å…ˆä¼šè°ƒç”¨ `operator.reader` è¿”å›ä¸€ä¸ªå®ç° `AsyncReader` + `AsyncSeek` çš„ `reader`](focus://2:5)ï¼Œ[å†å¥—ä¸€å±‚ `BufReader`](focus://7)ï¼›
[æœ€ç»ˆå°†è¯¥ `reader` ä¼ å…¥è‡³ `ParquetRecordBatchStreamBuilder` ä¸­](focus://9:11)ã€‚

<Callout type="info" emoji="ğŸ¥²">
  è¿™é‡Œé¢ `BufReader` ä¹Ÿæ˜¯å¤šæ­¤ä¸€ä¸¾ï¼Œ~~æˆ‘ä»¬åœ¨åé¢ä¼šæåˆ°ã€‚~~ï¼ˆç®—äº†ï¼Œä¸æƒ³å†™äº†ï¼›è‡ªå·±çœ‹ä»£ç å§ğŸ˜‡ï¼‰
</Callout>

```rust operator/src/statement/copy_table_from.rs focus=2:5,7,9
  ...
  let reader = operator
      .reader(path)
      .await
      .context(error::ReadObjectSnafu { path })?;

  let buf_reader = BufReader::new(reader.compat());

  let builder = ParquetRecordBatchStreamBuilder::new(buf_reader)
      .await
      .context(error::ReadParquetSnafu)?;

  let upstream = builder
      .build()
      .context(error::BuildParquetRecordBatchStreamSnafu)?;
  
  ...
```

---
### ParquetRecordBatchStream::new è¯»å–å…ƒä¿¡æ¯ 

è¯»å–å…ƒä¿¡æ¯é€»è¾‘å¦‚ä¸‹ï¼Œ[é¦–å…ˆè°ƒç”¨ `seek(SeekFrom::End(-FOOTER_SIZE_I64))` ï¼Œè¯»å– `FOOTER_SIZE` å­—èŠ‚åè§£æå‡º `metadata_len`](focus://21:26)ï¼›
[éšåå†ä¸€æ¬¡è°ƒç”¨ `seek`ï¼Œå¹¶è¯»å– `metadata_len` å­—èŠ‚åè§£æå‡ºå…ƒä¿¡æ¯](focus://26:31)ã€‚

```rust parquet/arrow/async_reader/mod.rs focus=21:31
impl<T: AsyncRead + AsyncSeek + Unpin + Send> AsyncFileReader for T {
    fn get_bytes(&mut self, range: Range<usize>) -> BoxFuture<'_, Result<Bytes>> {
        async move {
            self.seek(SeekFrom::Start(range.start as u64)).await?;

            let to_read = range.end - range.start;
            let mut buffer = Vec::with_capacity(to_read);
            let read = self.take(to_read as u64).read_to_end(&mut buffer).await?;
            if read != to_read {
                return Err(eof_err!("expected to read {} bytes, got {}", to_read, read));
            }

            Ok(buffer.into())
        }
        .boxed()
    }

    fn get_metadata(&mut self) -> BoxFuture<'_, Result<Arc<ParquetMetaData>>> {
        const FOOTER_SIZE_I64: i64 = FOOTER_SIZE as i64;
        async move {
            self.seek(SeekFrom::End(-FOOTER_SIZE_I64)).await?;

            let mut buf = [0_u8; FOOTER_SIZE];
            self.read_exact(&mut buf).await?;

            let metadata_len = decode_footer(&buf)?;
            self.seek(SeekFrom::End(-FOOTER_SIZE_I64 - metadata_len as i64))
                .await?;

            let mut buf = Vec::with_capacity(metadata_len);
            self.take(metadata_len as _).read_to_end(&mut buf).await?;

            Ok(Arc::new(decode_metadata(&buf)?))
        }
        .boxed()
    }
}
```

---
### çœŸæ­£çš„é—®é¢˜
åˆ°ä¸Šé¢ä¸ºæ­¢ï¼Œéƒ½æ˜¯ä¸€äº›çš„å°é—®é¢˜ã€‚[çœŸæ­£çš„æ¯”è¾ƒæ£˜æ‰‹çš„é—®é¢˜å‘ç”Ÿåœ¨è¿™é‡Œ](focus://3)ï¼Œè¿™é‡Œå˜é‡ `stream` å°±æ˜¯æˆ‘ä»¬ä¸Šé¢æ„å»ºçš„ `ParquetRecordBatchStream`ï¼Œå½“æˆ‘ä»¬è°ƒç”¨ `next` æ—¶ï¼Œå…¶å®ç°ä¼šè°ƒç”¨å¤šæ¬¡ `reader` (`RangeReader`)çš„ `seek` å’Œ `read`ã€‚
ç„¶è€Œè°ƒç”¨ `RangeReader` çš„ `read`ï¼Œé»˜è®¤ä¼šè¯»å– `[SeekPos, Size)` èŒƒå›´çš„æ‰€æœ‰å­—èŠ‚ã€‚ï¼ˆç›¸å…³ [issue](https://github.com/apache/incubator-opendal/issues/3747)ï¼‰

<Callout emoji="ğŸ¥µ">
**è¿™æ˜¯å¯¼è‡´å¯¼å…¥æ…¢çš„ä¸»è¦åŸå› ï¼Œæœ€ç»ˆæˆ‘ä»¬çš„ç³»ç»Ÿä» S3 è¯»å–äº†å¤§é‡çš„å­—èŠ‚éå¸¸å¤šæ¬¡ï¼Œå¹¶ä¸”æ¯æ¬¡åªä½¿ç”¨å…¶ä¸­æå°éƒ¨åˆ†ã€‚**ï¼ˆå¦‚æœè¿™äº›æ“ä½œéƒ½å‘é€åœ¨æ–‡ä»¶ç³»ç»Ÿä¸Šï¼Œåªä¸è¿‡æ˜¯å¢åŠ ä¸€äº›ç³»ç»Ÿè°ƒç”¨çš„å¼€é”€ï¼Œåç»­çš„è¯»å–éƒ½ä¼šå‡»ä¸­ `Page Cache`ï¼‰
</Callout>


```rust operator/src/statement/copy_table_from.rs focus=3:4
    pub async fn copy_table_from(
    ...
            while let Some(r) = stream.next().await {
                let record_batch = r.context(error::ReadDfRecordBatchSnafu)?;
                let vectors =
                    Helper::try_into_vectors(record_batch.columns()).context(IntoVectorsSnafu)?;

                pending_mem_size += vectors.iter().map(|v| v.memory_size()).sum::<usize>();

                let columns_values = fields
                    .iter()
                    .cloned()
                    .zip(vectors)
                    .collect::<HashMap<_, _>>();

                pending.push(self.inserter.handle_table_insert(
                    InsertRequest {
                        catalog_name: req.catalog_name.to_string(),
                        schema_name: req.schema_name.to_string(),
                        table_name: req.table_name.to_string(),
                        columns_values,
                    },
                    query_ctx.clone(),
                ));

                if pending_mem_size as u64 >= pending_mem_threshold {
                    rows_inserted += batch_insert(&mut pending, &mut pending_mem_size).await?;
                }
            }
    
    ...
```

</CH.Scrollycoding>

## è®©æˆ‘ä»¬æ¥è¯»ä¸€è¯» RangeReader çš„æºç 

<CH.Scrollycoding>
### å…ˆæ¥çœ‹çœ‹ `self.poll_read()`

`RangeReader` å…¶ `self.state` åˆå§‹å€¼ä¸º `State::Idle`ï¼Œé¦–å…ˆæˆ‘ä»¬å‡è®¾ `self.offset` ä¸º `Some(0)`ï¼›
[éšå `self.state` è¢«è®¾ç½®ä¸º `State::SendRead(BoxFuture<'static, Result<(RpRead, R)>>)`](focus://18:20)ï¼Œ
[å¹¶å†æ¬¡è°ƒç”¨ `self.poll_read(cx, buf)`](focus://20:23)ã€‚

```rust core/src/raw/oio/read/range_read.rs focus=12:23
impl<A, R> oio::Read for RangeReader<A, R>
where
    A: Accessor<Reader = R>,
    R: oio::Read,
{
    fn poll_read(&mut self, cx: &mut Context<'_>, buf: &mut [u8]) -> Poll<Result<usize>> {
        // Sanity check for normal cases.
        if buf.is_empty() || self.cur >= self.size.unwrap_or(u64::MAX) {
            return Poll::Ready(Ok(0));
        }

        match &mut self.state {
            State::Idle => {
                self.state = if self.offset.is_none() {
                    // Offset is none means we are doing tailing reading.
                    // we should stat first to get the correct offset.
                    State::SendStat(self.stat_future())
                } else {
                    State::SendRead(self.read_future())
                };

                self.poll_read(cx, buf)
            }
            State::SendStat(fut) => {
                let rp = ready!(Pin::new(fut).poll(cx)).map_err(|err| {
                    // If stat future returns an error, we should reset
                    // state to Idle so that we can retry it.
                    self.state = State::Idle;
                    err
                })?;

                let length = rp.into_metadata().content_length();
                self.fill_range(length).map_err(|err| {
                    // If stat future returns an error, we should reset
                    // state to Idle so that we can retry it.
                    self.state = State::Idle;
                    err
                })?;

                self.state = State::Idle;
                self.poll_read(cx, buf)
            }
            State::SendRead(fut) => {
                let (rp, r) = ready!(Pin::new(fut).poll(cx)).map_err(|err| {
                    // If read future returns an error, we should reset
                    // state to Idle so that we can retry it.
                    self.state = State::Idle;
                    err
                })?;

                // Set size if read returns size hint.
                if let Some(size) = rp.size() {
                    if size != 0 && self.size.is_none() {
                        self.size = Some(size + self.cur);
                    }
                }
                self.state = State::Read(r);
                self.poll_read(cx, buf)
            }
            State::Read(r) => match ready!(Pin::new(r).poll_read(cx, buf)) {
                Ok(0) => {
                    // Reset state to Idle after all data has been consumed.
                    self.state = State::Idle;
                    Poll::Ready(Ok(0))
                }
                Ok(n) => {
                    self.cur += n as u64;
                    Poll::Ready(Ok(n))
                }
                Err(e) => {
                    self.state = State::Idle;
                    Poll::Ready(Err(e))
                }
            },
        }
    }
}
```
---
### åœ¨ `self.read_future()` å‘ç”Ÿäº†ä»€ä¹ˆ
æ˜¾è€Œæ˜“è§ï¼Œ[`self.read_future()` è¿”å›äº†ä¸€ä¸ª `BoxedFuture`](focus://6)ï¼›
[åœ¨ `BoxedFuture` ä¸­è°ƒç”¨ `acc.read(&path, op).await` å‘èµ·äº†ä¸€ä¸ªè¯»è¯·æ±‚](focus://19)ã€‚
[äº§ç”Ÿä¹‹å‰æåˆ°é—®é¢˜çš„å…³é”®å…¶å®å‘ç”Ÿåœ¨ `self.calculate_range()` ä¸­](focus://17)ã€‚

```rust core/src/raw/oio/read/range_read.rs focus=6:20
impl<A, R> RangeReader<A, R>
where
    A: Accessor<Reader = R>,
    R: oio::Read,
{
    fn read_future(&self) -> BoxFuture<'static, Result<(RpRead, R)>> {
        let acc = self.acc.clone();
        let path = self.path.clone();

        let mut op = self.op.clone();
        // cur != 0 means we have read some data out, we should convert
        // the op into deterministic to avoid ETag changes.
        if self.cur != 0 {
            op = op.into_deterministic();
        }
        // Alter OpRead with correct calculated range.
        op = op.with_range(self.calculate_range());

        Box::pin(async move { acc.read(&path, op).await })
    }

    fn stat_future(&self) -> BoxFuture<'static, Result<RpStat>> {
        let acc = self.acc.clone();
        let path = self.path.clone();

        // Handle if-match and if-none-match correctly.
        let mut args = OpStat::default();
        // TODO: stat should support range to check if ETag matches.
        if self.op.range().is_full() {
            if let Some(v) = self.op.if_match() {
                args = args.with_if_match(v);
            }
            if let Some(v) = self.op.if_none_match() {
                args = args.with_if_none_match(v);
            }
        }

        Box::pin(async move { acc.stat(&path, args).await })
    }
}
```

---
### ç½ªé­ç¥¸é¦– `self.calculate_range()` ğŸ¥²

~~å°±æ˜¯ä½ æŠŠé¬¼å­å¼•åˆ°è¿™æ¥çš„ï¼ˆä¸²å°äº†ï¼‰~~ `BytesRange::new` çš„[ç¬¬ä¸€ä¸ªå‚æ•°ä¸º `offset: Option<u64>`](focus://21[24:47])ï¼Œ
[ç¬¬äºŒä¸ªå‚æ•°ä¸º `size: Option<u64>`](focus://21[49:80])ï¼Œå½“ `size` ä¸º `None` æ—¶ï¼Œ`size = len - offset`ã€‚
æœ€ç»ˆæ¯ä¸€æ¬¡ `read` é»˜è®¤ä¼šè¯»å– `[offset, len)` èŒƒå›´çš„å­—èŠ‚ã€‚

```rust core/src/raw/oio/read/range_read.rs focus=16:21
/// Safety: State will only be accessed under &mut.
unsafe impl<R> Sync for State<R> {}

impl<A, R> RangeReader<A, R>
where
    A: Accessor,
{
    /// Calculate the current range, maybe sent as next read request.
    ///
    /// # Panics
    ///
    /// Offset must be normalized before calling this function.
    ///
    /// - `..` should be transformed into `0..`
    /// - `..size` should be transformed into `(total-size)..total`.
    fn calculate_range(&self) -> BytesRange {
        let offset = self
            .offset
            .expect("offset must be set before calculating range");

        BytesRange::new(Some(offset + self.cur), self.size.map(|v| v - self.cur))
    }
}
```

---
### ä¹¦æ¥ä¸Šæ–‡ `self.poll_read()` 

åˆ°æ­¤ä¸ºæ­¢ï¼Œ`poll_read` è¿˜æ²¡æœ‰è¿”å›ï¼›åœ¨ä¸Šæ–‡ä¸­ `self.poll_read()` è¢«å†æ¬¡è°ƒç”¨ï¼Œæ­¤æ—¶ `self.state` ä¸º `State::SendRead(BoxFuture<'static, Result<(RpRead, R)>>)`ã€‚
è¿™é‡Œçš„ [`ready!(Pin::new(fut).poll(cx))`](focus://44:49) è¿”å›å€¼å°±æ˜¯ä¸Šæ–‡ä¸­ `acc.read(&path, op).await` è°ƒç”¨çš„è¿”å›å€¼ã€‚
[æœ€åå†…éƒ¨çŠ¶æ€ `self.state` è¢«è®¾ç½®ä¸º `State::Read(r)`ï¼Œå¹¶å†æ¬¡è°ƒç”¨ `self.poll_read()`](focus://57:58)ã€‚å‰©ä¸‹å†…å®¹å°±æ¯”è¾ƒç®€å•äº†ï¼Œå°±ä¸å†èµ˜è¿°äº†ã€‚

```rust core/src/raw/oio/read/range_read.rs focus=43:59
impl<A, R> oio::Read for RangeReader<A, R>
where
    A: Accessor<Reader = R>,
    R: oio::Read,
{
    fn poll_read(&mut self, cx: &mut Context<'_>, buf: &mut [u8]) -> Poll<Result<usize>> {
        // Sanity check for normal cases.
        if buf.is_empty() || self.cur >= self.size.unwrap_or(u64::MAX) {
            return Poll::Ready(Ok(0));
        }

        match &mut self.state {
            State::Idle => {
                self.state = if self.offset.is_none() {
                    // Offset is none means we are doing tailing reading.
                    // we should stat first to get the correct offset.
                    State::SendStat(self.stat_future())
                } else {
                    State::SendRead(self.read_future())
                };

                self.poll_read(cx, buf)
            }
            State::SendStat(fut) => {
                let rp = ready!(Pin::new(fut).poll(cx)).map_err(|err| {
                    // If stat future returns an error, we should reset
                    // state to Idle so that we can retry it.
                    self.state = State::Idle;
                    err
                })?;

                let length = rp.into_metadata().content_length();
                self.fill_range(length).map_err(|err| {
                    // If stat future returns an error, we should reset
                    // state to Idle so that we can retry it.
                    self.state = State::Idle;
                    err
                })?;

                self.state = State::Idle;
                self.poll_read(cx, buf)
            }
            State::SendRead(fut) => {
                let (rp, r) = ready!(Pin::new(fut).poll(cx)).map_err(|err| {
                    // If read future returns an error, we should reset
                    // state to Idle so that we can retry it.
                    self.state = State::Idle;
                    err
                })?;

                // Set size if read returns size hint.
                if let Some(size) = rp.size() {
                    if size != 0 && self.size.is_none() {
                        self.size = Some(size + self.cur);
                    }
                }
                self.state = State::Read(r);
                self.poll_read(cx, buf)
            }
            State::Read(r) => match ready!(Pin::new(r).poll_read(cx, buf)) {
                Ok(0) => {
                    // Reset state to Idle after all data has been consumed.
                    self.state = State::Idle;
                    Poll::Ready(Ok(0))
                }
                Ok(n) => {
                    self.cur += n as u64;
                    Poll::Ready(Ok(n))
                }
                Err(e) => {
                    self.state = State::Idle;
                    Poll::Ready(Err(e))
                }
            },
        }
    }
}
```

---
### æœ€åçœ‹ä¸‹ `self.poll_seek()` 
è¿™é‡Œåªæœ‰ä¸€ä¸ªæ€§èƒ½ç›¸å…³çš„é‡ç‚¹ï¼Œ[å½“æˆ‘ä»¬å°è¯• `SeekFrom::End()` çš„æ—¶ï¼Œä¸” `self.size` æœªçŸ¥æ—¶ï¼Œä¼šæœ‰ä¸€æ¬¡é¢å¤–çš„ `stat` æ“ä½œ](focus://15:18)ã€‚
[`self.poll_seek()` è°ƒç”¨å `self.cur` ä¼šè¢«è®¾ç½®ä¸º `base.checked_add(amt)`](focus://22:33)ã€‚

```rust core/src/raw/oio/read/range_read.rs focus=7:34
impl<A, R> oio::Read for RangeReader<A, R>
where
    A: Accessor<Reader = R>,
    R: oio::Read,
{
    fn poll_seek(&mut self, cx: &mut Context<'_>, pos: SeekFrom) -> Poll<Result<u64>> {
        match &mut self.state {
            State::Idle => {
                let (base, amt) = match pos {
                    SeekFrom::Start(n) => (0, n as i64),
                    SeekFrom::Current(n) => (self.cur as i64, n),
                    SeekFrom::End(n) => {
                        if let Some(size) = self.size {
                            (size as i64, n)
                        } else {
                            self.state = State::SendStat(self.stat_future());
                            return self.poll_seek(cx, pos);
                        }
                    }
                };

                let seek_pos = match base.checked_add(amt) {
                    Some(n) if n >= 0 => n as u64,
                    _ => {
                        return Poll::Ready(Err(Error::new(
                            ErrorKind::InvalidInput,
                            "invalid seek to a negative or overflowing position",
                        )))
                    }
                };

                self.cur = seek_pos;
                Poll::Ready(Ok(self.cur))
            }
            State::SendStat(fut) => {
                let rp = ready!(Pin::new(fut).poll(cx)).map_err(|err| {
                    // If stat future returns an error, we should reset
                    // state to Idle so that we can retry it.
                    self.state = State::Idle;
                    err
                })?;

                let length = rp.into_metadata().content_length();
                self.fill_range(length)?;

                self.state = State::Idle;
                self.poll_seek(cx, pos)
            }
            State::SendRead(_) => {
                // It's impossible for us to go into this state while
                // poll_seek. We can just drop this future and check state.
                self.state = State::Idle;
                self.poll_seek(cx, pos)
            }
            State::Read(_) => {
                // There is an optimization here that we can calculate if users trying to seek
                // the same position, for example, `reader.seek(SeekFrom::Current(0))`.
                // In this case, we can just return current position without dropping reader.
                if pos == SeekFrom::Current(0) || pos == SeekFrom::Start(self.cur) {
                    return Poll::Ready(Ok(self.cur));
                }

                self.state = State::Idle;
                self.poll_seek(cx, pos)
            }
        }
    }
}
```

</CH.Scrollycoding>

## åç»­
é¦–å…ˆä¼šè¦ä¿®å¤æ‰ RangeReader é»˜è®¤è¯» `[Offest, Size)` èŒƒå›´å­—èŠ‚çš„[é—®é¢˜](https://github.com/apache/incubator-opendal/issues/3747)ã€‚

éšåï¼Œè¿™ä¸ª [RFC](https://github.com/apache/incubator-opendal/pull/3734) ä¼šä¸º CompleteLayer Reader å¼•å…¥ä¸€ä¸ª `Buffer`ï¼Œç¼“è§£é¢‘ç¹ IO å¸¦æ¥çš„å¼€é”€ã€‚
```rust
  let reader = op.reader_with("path").buffer(32 * 1024 * 1024).await;
```
æœ€åï¼ŒReader ä¼šæ”¯æŒå¹¶è¡ŒåŠ è½½æ•°æ®ï¼Œä¸»è¦æ˜¯é’ˆå¯¹ S3 è¿™ç±»å­˜å‚¨åç«¯çš„ä¼˜åŒ–ã€‚
```rust
  let reader = op.reader_with("path").buffer(32 * 1024 * 1024).concurrent(4).await;
```
