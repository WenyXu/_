---
title: OpenDAL RangeReader çš„å¥¥å¦™
date: 2022/12/16
description: è¯´äº†å¤šå°‘éäº†è¦ RTFSCï¼ŒRTFSC
tag: Rust, OpenDAL
author: Weny
---

import { Callout } from 'nextra/components'

## å‰æƒ…æè¦

æˆ‘ä»¬([GreptimeDB](https://github.com/greptimeTeam/greptimedb/))æŠŠ [OpenDAL](https://github.com/apache/incubator-opendal) ä½œä¸ºç»Ÿä¸€çš„æ•°æ®è®¿é—®å±‚ã€‚å‰æ®µæ—¶é—´åŒäº‹å‘Šè¯‰æˆ‘ï¼Œæ•°æ®åº“æ‰§è¡Œ `Copy From` è¯­å¥ä» S3 å¯¼å…¥ä¸€ä¸ª 800 KiB çš„ Parquet æ–‡ä»¶éœ€è¦ 10sï¼›ç»è¿‡ä¸€äº›è°ƒæŸ¥ï¼Œç ”è¯»äº†ç›¸å…³ Reader çš„æ–‡æ¡£å’Œå…·ä½“å®ç° ~~ï¼ˆæš´éœ²äº†ä¹‹å‰æ²¡æœ‰ RTFSC ğŸ¥²ï¼‰~~ï¼Œè°¨ä»¥æœ¬æ–‡åšä¸€ä¸ªè®°å½•å’Œç®€å•çš„æ€»ç»“ã€‚

<Callout type="info" emoji="â„¹ï¸">
  æœ¬æ–‡æ¶‰åŠçš„ OpenDAL æºç  Commit: [6980cd1](https://github.com/apache/incubator-opendal/tree/6980cd15007c9a2ae8422cbc0750c818e178abf2)
</Callout>

## TL;DR

- OpenDAL `RangeReader` è°ƒç”¨ `seek` æ–¹æ³•åä¼šé‡ç½®å†…éƒ¨çŠ¶æ€ï¼Œä¸‹ä¸€æ¬¡è°ƒç”¨ `read` è°ƒç”¨ä¼šæœ‰ä¸€æ¬¡è¿œç¨‹è°ƒç”¨è¯·æ±‚ï¼ˆåç«¯ä¸º S3 çš„åœºæ™¯ï¼‰ã€‚ï¼ˆç›¸å…³ [issue](https://github.com/apache/incubator-opendal/issues/3747) å’Œ[è®¨è®º](https://github.com/apache/incubator-opendal/pull/3734)ï¼‰
- `std::io::BufReader` å’Œ  `tokio::io::BufReader` éƒ½ä¼šåœ¨ `seek` åæ¸…é™¤å†…éƒ¨ `Buffer`ï¼Œå¦‚æœå¸Œæœ›ç»§ç»­è¯» `Buffer` å†…çš„å†…å®¹ï¼Œåº”è¯¥è°ƒç”¨ `seek_relative`ã€‚
- ä» S3 è¯»å–å…ƒä¿¡æ¯åœ¨å°¾éƒ¨æ–‡ä»¶æ ¼å¼ï¼Œå¯ä»¥è€ƒè™‘åŠ ä¸€å±‚ `Tailing Buffer` (å³ï¼Œä»»ä½•è½å…¥ç”¨æˆ·å®šä¹‰çš„ `Tailing Bytes` èŒƒå›´å†…çš„ `seek` çš„æ“ä½œï¼Œåªåœ¨ç¬¬ä¸€æ¬¡åŠ è½½å¹¶ç¼“å­˜ `Tailing Bytes`)ï¼Œä¸€äº›åœºæ™¯å¯ä»¥å‡å°‘ä¸€æ¬¡ S3 get è¯·æ±‚(è¿™ä¸ªæœ¬è´¨ä¸Šæ˜¯ä¸€ç§åˆ†å¼€è¯»å°¾éƒ¨å…ƒä¿¡æ¯çš„æ›¿æ¢æ–¹æ¡ˆ)ã€‚


## å…ˆæ¥èŠèŠè¯¥æ€ä¹ˆè¯» OpenDAL æºç ï¼Ÿ

å¦ç™½è¯´ï¼Œæˆ‘ä¹Ÿæ˜¯æœ€è¿‘æ‰ç†æ¸…æ¥š OpenDAL çš„æºç å’Œå…¶è°ƒç”¨å…³ç³»ï¼Œä¹‹å‰éƒ½æ˜¯ä¸€çŸ¥åŠè§£ã€‚

<CH.Scrollycoding>
### ä» Operator å¼€å§‹

æˆ‘ä»¬æ‰€æœ‰çš„ IO æ“ä½œéƒ½æ˜¯å›´ç»•ç€ `Operator` å±•å¼€çš„ï¼Œå…ˆæ¥çœ‹ä¸‹ `Operator` æ˜¯æ€ä¹ˆæ„å»ºçš„ã€‚
ä»¥ `main.rs` ä¸ºä¾‹ï¼Œé¦–å…ˆæˆ‘ä»¬[åœ¨ L7 åˆ›å»ºäº†ä¸€ä¸ªåŸºäºæ–‡ä»¶ç³»ç»Ÿçš„ `Backend Builder`](focus://7)ï¼›
[åœ¨ L13 å°†å…¶æ„å»ºä¸º `accessor`ï¼ˆå®ç°äº† `Accessor` trait)](focus://13)ï¼›
[L14 æˆ‘ä»¬å°†è¯¥ `accessor` ä¼ å…¥äº† `OperatorBuilder::new`ï¼Œæœ€åè°ƒç”¨äº† `finish`ã€‚](focus://14) 


<Callout type="info" emoji="â„¹ï¸">
  OpenDAL é€šè¿‡ `Accessor` trait ç»Ÿä¸€äº†ä¸åŒå­˜å‚¨åç«¯(Backend)çš„è¡Œä¸ºï¼Œå¹¶å‘ä¸Šå±‚æš´éœ²ç»Ÿä¸€çš„ IO æ¥å£ï¼Œä¾‹å¦‚ `create_dir`, `read`, `write` ç­‰ã€‚
</Callout>


```rust main.rs focus=7,13:14
use opendal::services::Fs;
use opendal::Operator;

#[tokio::main]
async fn main() -> Result<()> {
    // Create fs backend builder.
    let mut builder = Fs::default();
    // Set the root for fs, all operations will happen under this root.
    //
    // NOTE: the root must be absolute path.
    builder.root("/tmp");

    let accessor = builder.build()?;
    let op: Operator = OperatorBuilder::new(accessor)?.finish();

    Ok(())
}
```

---

### åœ¨ OperatorBuilder::new å‘ç”Ÿäº†ä»€ä¹ˆ
æˆ‘ä»¬ä¼ å…¥çš„ `accessor` åœ¨è°ƒç”¨ `new` æ—¶ï¼Œ[è¢«è¿½åŠ äº†ä¸¤å±‚ `Layer`](focus://6:8)ï¼Œå¹¶åœ¨è°ƒç”¨ `finish` æ—¶ï¼Œ[è¢«è¿½åŠ äº†ä¸€å±‚å†…éƒ¨ `Layer`](focus://15:16)ã€‚


```rust src/types/operator/builder.rs focus=6:8,15:16
impl<A: Accessor> OperatorBuilder<A> {
    /// Create a new operator builder.
    #[allow(clippy::new_ret_no_self)]
    pub fn new(accessor: A) -> OperatorBuilder<impl Accessor> {
        // Make sure error context layer has been attached.
        OperatorBuilder { accessor }
            .layer(ErrorContextLayer)
            .layer(CompleteLayer)
    }

    ...
    
    /// Finish the building to construct an Operator.
    pub fn finish(self) -> Operator {
        let ob = self.layer(TypeEraseLayer);
        Operator::from_inner(Arc::new(ob.accessor) as FusedAccessor)
    }
}
```

è¿½åŠ  `Layer` åï¼Œå½“æˆ‘ä»¬è°ƒç”¨ `Operator` æš´éœ²å‡ºæ¥çš„æ¥å£æ—¶ï¼Œè°ƒç”¨ä¼šä»æœ€å¤–å±‚ `CompleteLayer`å¼€å§‹ï¼Œå¹¶æœ€ç»ˆæŠµè¾¾æœ€å†…å±‚ `FsAccessor`ã€‚

```
FsAccessor
ErrorContextLayer
CompleteLayer
^
|
| Invoking (`read`, `reader_with`, `stat`...)
```

<Callout type="info" emoji="ğŸ¤£">
  **TL;DR** å…¶å®è¯´äº†åŠå¤©ï¼Œæƒ³å¼ºè°ƒä¸€ä¸‹ï¼Œä»£ç åº”è¯¥ä» `CompleteLayer` å¼€å§‹è¯»ï¼ˆå¤§é›¾
</Callout>


</CH.Scrollycoding>

## æˆ‘ä»¬çš„ä¸Šä¸‹æ–‡
è¿™é‡Œæˆ‘ä»¬è¡¥å……ä¸€äº›å¿…è¦çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œä»¥ä¾¿ç†è§£åæ–‡å†…å®¹ã€‚

### LruCacheLayer
ç›®å‰ï¼Œåœ¨æŸ¥è¯¢åœºæ™¯ï¼Œæˆ‘ä»¬è¿½åŠ äº†ä¸€å±‚ `LruCacheLayer`ï¼Œé‚£ä¹ˆæˆ‘ä»¬ `Operator` å°±å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

```
S3Accessor                FsAccessor
ErrorContextLayer         ErrorContextLayer
CompleteLayer             CompleteLayer
    â–²                         â–²  â”‚
    â”‚                         â”‚  â”‚
    â”‚`inner`           `cache`â”‚  â”‚
    â”‚                         â”‚  â”‚
    â”‚                         â”‚  â”‚
    â”‚                         â”‚  â”‚
    â””â”€â”€â”€â”€â”€ LruCacheLayer â”€â”€â”€â”€â”€â”˜  â”‚
                 â–²               â”‚      
                 â”‚               â”‚
                 â”‚               â”‚ 
                 â”‚               â–¼
                 â”‚               FileReader::new(oio::TokioReader<tokio::fs::File>) 
                 â”‚ 
                 Invoking(`reader`, `reader_with`)  
      
```

<CH.Section>

ä»¥ `read` æ¥å£ä¸ºä¾‹ï¼Œ`LruCacheLayer`ä¼šå°† S3 çš„æ–‡ä»¶ç¼“å­˜åˆ°æ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œ
[å¹¶å‘ä¸Šå±‚è¿”å›ç¼“å­˜çš„åŸºäºæ–‡ä»¶ç³»ç»Ÿçš„ `Box<dyn oio::Read>`(`FileReader::new(oio::TokioReader<tokio::fs::File>)`)](focus://10:12)ï¼›
å½“ç„¶å¦‚æœè¯»å–çš„æ–‡ä»¶ä¸å­˜åœ¨äºç¼“å­˜æ—¶ï¼Œ[åˆ™å…ˆå…¨é‡ä» S3 åŠ è½½æ–‡ä»¶è‡³æœ¬åœ°çš„æ–‡ä»¶ç³»ç»Ÿä¸­](focus://13:15)ã€‚

<Callout type="warning" emoji="ğŸ¥º">    
    å½“ RangeReader çš„ `read` è¢«è°ƒç”¨æ—¶ï¼Œä¼šå»ºç«‹å–å›æ–‡ä»¶çš„ TCP è¿æ¥ï¼Œä»¥å­—èŠ‚æµçš„å½¢å¼è¿”å›ç»™ä¸Šå±‚ï¼Œ
    ä¸Šå±‚åº”ç”¨å¯èƒ½åªéœ€è¦è¯»å–è‹¥å¹²å­—èŠ‚å°±å…³é—­äº†å­—èŠ‚æµï¼ˆå¹¶å…³é—­äº† TCP è¿æ¥ï¼‰ã€‚
    ç„¶è€Œå½“æˆ‘ä»¬è°ƒç”¨ `let reader = op.reader_with()` æ—¶ï¼Œæˆ‘ä»¬çš„ç¼“å­˜å±‚ä¼šå…¨é‡åŠ è½½å¯¹åº”æ–‡ä»¶å¹¶ç¼“å­˜æ•´ä¸ªæ–‡ä»¶ã€‚
    è¿™é‡Œæœªæ¥å¯ä»¥åšä¸€ä¸ªæ‡’åŠ è½½çš„ä¼˜åŒ–ï¼ˆå³ï¼Œåœ¨ `reader.read()` è¢«è°ƒç”¨æ—¶æ‰å»è¯·æ±‚å¯¹åº”å­—èŠ‚æˆ–åŠ è½½å¯¹åº”ç¼“å­˜ï¼‰ã€‚
</Callout>

```rust
struct LruCacheLayer {
  inner: Operator, // S3Backend
  cache: Operator, // FsBackend
  index: CacheIndex
}

impl LayeredAccessor for LruCacheLayer {
  ...
  async fn read(&self, path: &str, args: OpRead) -> Result<(RpRead, Self::Reader)> {
        if self.index.hit(path, args) {
          // Returns `Box<dyn oio::Read>`
          self.cache.read(path, args).await 
        } else {
          // Fetches cache and stores...
        }
  }
  ...
}
```

</CH.Section>


### Copy From çš„åœºæ™¯

åœ¨ `Copy From` åœºæ™¯ï¼Œæˆ‘å¹¶æ²¡æœ‰åŠ è¿™ä¸€å±‚ `LruCacheLayer`ã€‚é‚£ä¹ˆæˆ‘ä»¬ `Operator` å°±å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š
```
S3Accessor
ErrorContextLayer
CompleteLayer
   â–²    â”‚
   â”‚    â”‚
   â”‚    â”‚
   â”‚    â–¼ 
   â”‚    RangeReader::new(IncomingAsyncBody)
   â”‚
   Invoking (`reader`, `reader_with`)
```
å…³äºä¸ºä»€ä¹ˆæ²¡æœ‰åŠ  `Cache` åŸå› å¦‚ä¸‹ï¼š
1. é”™è¯¯ç†è§£ OpenDAL `Reader` å·¥ä½œæ–¹å¼ï¼Œå½“æ—¶ä»¥ä¸º `Reader` åœ¨å…¶ç”Ÿå‘½å‘¨æœŸå†…ï¼Œåœ¨å…¶å…¨é‡è¯»å– S3 æ–‡ä»¶åï¼Œè°ƒç”¨å…¶ `seek`, `read` ä¸éœ€è¦é¢å¤–çš„ S3 get è¯·æ±‚ã€‚
2. `Copy From` çš„æ–‡ä»¶é€šå¸¸åªä¼šè¢«è¯»å–ä¸€æ¬¡ï¼Œå½“æ—¶è®¤ä¸ºåŠ ä¸€å±‚ `Cache` å¹¶æ²¡æœ‰ä¸å¤§ã€‚

æ€»ä¹‹å°±æ˜¯æˆ‘å½“æ—¶å†™çš„ä¸è¡ŒğŸ¥¹

## åœ¨ä½¿ç”¨ RangeReader æ—¶é‡åˆ°çš„é—®é¢˜

<CH.Scrollycoding>
### ä»æ„å»º ParquetRecordBatchStream è¯´èµ·
åœ¨ `Copy From` ä¸­ï¼Œæˆ‘ä»¬æ‹¿åˆ°æ–‡ä»¶ä¿¡æ¯åï¼Œ[é¦–å…ˆä¼šè°ƒç”¨ `operator.reader` è¿”å›ä¸€ä¸ªå®ç° `AsyncReader` + `AsyncSeek` çš„ `reader`](focus://2:5)ï¼Œ[å†å¥—ä¸€å±‚ `BufReader`](focus://7)ï¼›
[æœ€ç»ˆå°†è¯¥ `reader` ä¼ å…¥è‡³ `ParquetRecordBatchStreamBuilder` ä¸­](focus://9:11)ã€‚

<Callout type="info" emoji="ğŸ¥²">
  è¿™é‡Œé¢ `BufReader` ä¹Ÿæ˜¯å¤šæ­¤ä¸€ä¸¾ï¼Œ~~æˆ‘ä»¬åœ¨åé¢ä¼šæåˆ°ã€‚~~ï¼ˆç®—äº†ï¼Œä¸æƒ³å†™äº†ï¼›è‡ªå·±çœ‹ä»£ç å§ğŸ˜‡ï¼‰
</Callout>

```rust operator/src/statement/copy_table_from.rs focus=2:5,7,9
  ...
  let reader = operator
      .reader(path)
      .await
      .context(error::ReadObjectSnafu { path })?;

  let buf_reader = BufReader::new(reader.compat());

  let builder = ParquetRecordBatchStreamBuilder::new(buf_reader)
      .await
      .context(error::ReadParquetSnafu)?;

  let upstream = builder
      .build()
      .context(error::BuildParquetRecordBatchStreamSnafu)?;
  
  ...
```

---
### ParquetRecordBatchStream::new è¯»å–å…ƒä¿¡æ¯ 

è¯»å–å…ƒä¿¡æ¯é€»è¾‘å¦‚ä¸‹ï¼Œ[é¦–å…ˆè°ƒç”¨ `seek(SeekFrom::End(-FOOTER_SIZE_I64))` ï¼Œè¯»å– `FOOTER_SIZE` å­—èŠ‚åè§£æå‡º `metadata_len`](focus://21:26)ï¼›
[éšåå†ä¸€æ¬¡è°ƒç”¨ `seek`ï¼Œå¹¶è¯»å– `metadata_len` å­—èŠ‚åè§£æå‡ºå…ƒä¿¡æ¯](focus://26:31)ã€‚

```rust parquet/arrow/async_reader/mod.rs focus=21:31
impl<T: AsyncRead + AsyncSeek + Unpin + Send> AsyncFileReader for T {
    fn get_bytes(&mut self, range: Range<usize>) -> BoxFuture<'_, Result<Bytes>> {
        async move {
            self.seek(SeekFrom::Start(range.start as u64)).await?;

            let to_read = range.end - range.start;
            let mut buffer = Vec::with_capacity(to_read);
            let read = self.take(to_read as u64).read_to_end(&mut buffer).await?;
            if read != to_read {
                return Err(eof_err!("expected to read {} bytes, got {}", to_read, read));
            }

            Ok(buffer.into())
        }
        .boxed()
    }

    fn get_metadata(&mut self) -> BoxFuture<'_, Result<Arc<ParquetMetaData>>> {
        const FOOTER_SIZE_I64: i64 = FOOTER_SIZE as i64;
        async move {
            self.seek(SeekFrom::End(-FOOTER_SIZE_I64)).await?;

            let mut buf = [0_u8; FOOTER_SIZE];
            self.read_exact(&mut buf).await?;

            let metadata_len = decode_footer(&buf)?;
            self.seek(SeekFrom::End(-FOOTER_SIZE_I64 - metadata_len as i64))
                .await?;

            let mut buf = Vec::with_capacity(metadata_len);
            self.take(metadata_len as _).read_to_end(&mut buf).await?;

            Ok(Arc::new(decode_metadata(&buf)?))
        }
        .boxed()
    }
}
```

---
### çœŸæ­£çš„é—®é¢˜
åˆ°ä¸Šé¢ä¸ºæ­¢ï¼Œéƒ½æ˜¯ä¸€äº›å°é—®é¢˜ã€‚[çœŸæ­£æ¯”è¾ƒæ£˜æ‰‹çš„é—®é¢˜å‘ç”Ÿåœ¨è¿™é‡Œ](focus://3)ï¼Œè¿™é‡Œå˜é‡ `stream` å°±æ˜¯æˆ‘ä»¬ä¸Šé¢æ„å»ºçš„ `ParquetRecordBatchStream`ï¼Œå½“æˆ‘ä»¬è°ƒç”¨ `next` æ—¶ï¼Œ`ParquetRecordBatchStream` ä¼šè°ƒç”¨å¤šæ¬¡ `reader` (`RangeReader`)çš„ `seek` å’Œ `read`ã€‚
ç„¶è€Œæ¯æ¬¡è°ƒç”¨ `seek` éƒ½ä¼šé‡ç½® `RangeReader` çš„å†…éƒ¨çŠ¶æ€ï¼ˆä¸¢å¼ƒæ‰ä¹‹å‰çš„å­—èŠ‚æµï¼‰ï¼Œå¹¶åœ¨ä¸‹æ¬¡è°ƒç”¨ `read` æ—¶ï¼Œé‡æ–°å‘èµ·ä¸€ä¸ªè¿œç¨‹è¯·æ±‚ï¼ˆåç«¯ä¸º S3 çš„åœºæ™¯ï¼‰ã€‚ï¼ˆç›¸å…³ [issue](https://github.com/apache/incubator-opendal/issues/3747) å’Œ[è®¨è®º](https://github.com/apache/incubator-opendal/pull/3734)ï¼‰

<Callout emoji="ğŸ¥µ">
`ParquetRecordBatchStream` åœ¨å–å›æ¯åˆ—æ•°æ®æ—¶ï¼šä¼šå…ˆè°ƒç”¨ RangeReader `seek`ï¼Œéšåè°ƒç”¨ `read` è¯»å–ä¸€äº›å­—èŠ‚ã€‚é‚£ä¹ˆæ€»å…±éœ€è¦å‘èµ·çš„è¿œç¨‹è°ƒç”¨æ¬¡æ•°ä¸º `RowGroup æ•°`ä¹˜ä¸Š `RowGroup å†…åˆ—çš„æ•°`ã€‚
æˆ‘ä»¬ 800KiB åŒ…å«äº† 50 ä¸ª RowGroup å’Œ 12 åˆ—ï¼Œä¹Ÿå°±æ˜¯å‘èµ·äº† 600 æ¬¡ S3 get è¯·æ±‚ï¼
</Callout>


```rust operator/src/statement/copy_table_from.rs focus=3:4
    pub async fn copy_table_from(
    ...
            while let Some(r) = stream.next().await {
                let record_batch = r.context(error::ReadDfRecordBatchSnafu)?;
                let vectors =
                    Helper::try_into_vectors(record_batch.columns()).context(IntoVectorsSnafu)?;

                pending_mem_size += vectors.iter().map(|v| v.memory_size()).sum::<usize>();

                let columns_values = fields
                    .iter()
                    .cloned()
                    .zip(vectors)
                    .collect::<HashMap<_, _>>();

                pending.push(self.inserter.handle_table_insert(
                    InsertRequest {
                        catalog_name: req.catalog_name.to_string(),
                        schema_name: req.schema_name.to_string(),
                        table_name: req.table_name.to_string(),
                        columns_values,
                    },
                    query_ctx.clone(),
                ));

                if pending_mem_size as u64 >= pending_mem_threshold {
                    rows_inserted += batch_insert(&mut pending, &mut pending_mem_size).await?;
                }
            }
    
    ...
```

</CH.Scrollycoding>

## è¯»ä¸€è¯» RangeReader çš„æºç 

`RangeReader` å…¶æ ¸å¿ƒåŠŸèƒ½æ˜¯å°† non-seekable çš„ `Reader` å˜æˆä¸€ä¸ª seekable çš„ `Reader`ã€‚åœ¨ `seek(pos)` è¢«è°ƒç”¨åï¼Œä¸‹æ¬¡ `read` è°ƒç”¨ä¾¿ä¼šè¯·æ±‚åº•å±‚æœåŠ¡é‡æ–°è¿”å›ä¸€ä¸ªåŒ…å« `[pos,size)` çš„ `Reader`ã€‚

<CH.Scrollycoding>
### çœ‹çœ‹ `self.poll_read()`

`RangeReader` å…¶ `self.state` åˆå§‹å€¼ä¸º `State::Idle`ï¼Œé¦–å…ˆæˆ‘ä»¬å‡è®¾ `self.offset` ä¸º `Some(0)`ï¼›
[éšå `self.state` è¢«è®¾ç½®ä¸º `State::SendRead(BoxFuture<'static, Result<(RpRead, R)>>)`](focus://18:20)ï¼Œ
[å¹¶å†æ¬¡è°ƒç”¨ `self.poll_read(cx, buf)`](focus://20:23)ã€‚

```rust core/src/raw/oio/read/range_read.rs focus=12:23
impl<A, R> oio::Read for RangeReader<A, R>
where
    A: Accessor<Reader = R>,
    R: oio::Read,
{
    fn poll_read(&mut self, cx: &mut Context<'_>, buf: &mut [u8]) -> Poll<Result<usize>> {
        // Sanity check for normal cases.
        if buf.is_empty() || self.cur >= self.size.unwrap_or(u64::MAX) {
            return Poll::Ready(Ok(0));
        }

        match &mut self.state {
            State::Idle => {
                self.state = if self.offset.is_none() {
                    // Offset is none means we are doing tailing reading.
                    // we should stat first to get the correct offset.
                    State::SendStat(self.stat_future())
                } else {
                    State::SendRead(self.read_future())
                };

                self.poll_read(cx, buf)
            }
            State::SendStat(fut) => {
                let rp = ready!(Pin::new(fut).poll(cx)).map_err(|err| {
                    // If stat future returns an error, we should reset
                    // state to Idle so that we can retry it.
                    self.state = State::Idle;
                    err
                })?;

                let length = rp.into_metadata().content_length();
                self.fill_range(length).map_err(|err| {
                    // If stat future returns an error, we should reset
                    // state to Idle so that we can retry it.
                    self.state = State::Idle;
                    err
                })?;

                self.state = State::Idle;
                self.poll_read(cx, buf)
            }
            State::SendRead(fut) => {
                let (rp, r) = ready!(Pin::new(fut).poll(cx)).map_err(|err| {
                    // If read future returns an error, we should reset
                    // state to Idle so that we can retry it.
                    self.state = State::Idle;
                    err
                })?;

                // Set size if read returns size hint.
                if let Some(size) = rp.size() {
                    if size != 0 && self.size.is_none() {
                        self.size = Some(size + self.cur);
                    }
                }
                self.state = State::Read(r);
                self.poll_read(cx, buf)
            }
            State::Read(r) => match ready!(Pin::new(r).poll_read(cx, buf)) {
                Ok(0) => {
                    // Reset state to Idle after all data has been consumed.
                    self.state = State::Idle;
                    Poll::Ready(Ok(0))
                }
                Ok(n) => {
                    self.cur += n as u64;
                    Poll::Ready(Ok(n))
                }
                Err(e) => {
                    self.state = State::Idle;
                    Poll::Ready(Err(e))
                }
            },
        }
    }
}
```
---
### åœ¨ `self.read_future()` å‘ç”Ÿäº†ä»€ä¹ˆ
æ˜¾è€Œæ˜“è§ï¼Œ[`self.read_future()` è¿”å›äº†ä¸€ä¸ª `BoxedFuture`](focus://6)ï¼›
[åœ¨ `BoxedFuture` ä¸­è°ƒç”¨åº•å±‚çš„ `Accessor` çš„ `read` æ¥å£(`acc.read(&path, op).await`)](focus://19)ã€‚
`Accessor` å¯ä»¥æ˜¯ S3 çš„å­˜å‚¨åç«¯å®ç°ï¼Œä¹Ÿå¯ä»¥æ˜¯ OSS å®ç°ç­‰ï¼›å½“å®ƒçš„ `read` æ¥å£è¢«è°ƒç”¨æ—¶ï¼Œä¼šå»ºç«‹å–å›æ–‡ä»¶çš„ TCP è¿æ¥ï¼Œå¹¶å°†å“åº”ä»¥å­—èŠ‚æµçš„å½¢å¼è¿”å›ç»™ä¸Šå±‚ã€‚

```rust core/src/raw/oio/read/range_read.rs focus=6:20
impl<A, R> RangeReader<A, R>
where
    A: Accessor<Reader = R>,
    R: oio::Read,
{
    fn read_future(&self) -> BoxFuture<'static, Result<(RpRead, R)>> {
        let acc = self.acc.clone();
        let path = self.path.clone();

        let mut op = self.op.clone();
        // cur != 0 means we have read some data out, we should convert
        // the op into deterministic to avoid ETag changes.
        if self.cur != 0 {
            op = op.into_deterministic();
        }
        // Alter OpRead with correct calculated range.
        op = op.with_range(self.calculate_range());

        Box::pin(async move { acc.read(&path, op).await })
    }

    fn stat_future(&self) -> BoxFuture<'static, Result<RpStat>> {
        let acc = self.acc.clone();
        let path = self.path.clone();

        // Handle if-match and if-none-match correctly.
        let mut args = OpStat::default();
        // TODO: stat should support range to check if ETag matches.
        if self.op.range().is_full() {
            if let Some(v) = self.op.if_match() {
                args = args.with_if_match(v);
            }
            if let Some(v) = self.op.if_none_match() {
                args = args.with_if_none_match(v);
            }
        }

        Box::pin(async move { acc.stat(&path, args).await })
    }
}
```

---
### å†æ¬¡è°ƒç”¨ `self.poll_read()` 

åˆ°æ­¤ä¸ºæ­¢ï¼Œ`poll_read` è¿˜æ²¡æœ‰è¿”å›ï¼›åœ¨ä¸Šæ–‡ä¸­ `self.poll_read()` è¢«å†æ¬¡è°ƒç”¨ï¼Œæ­¤æ—¶ `self.state` ä¸º `State::SendRead(BoxFuture<'static, Result<(RpRead, R)>>)`ã€‚
è¿™é‡Œçš„ [`ready!(Pin::new(fut).poll(cx))`](focus://44:49) è¿”å›å€¼å°±æ˜¯ä¸Šæ–‡ä¸­ `acc.read(&path, op).await` è°ƒç”¨çš„è¿”å›å€¼ã€‚ï¼ˆå¯¹äº S3 å­˜å‚¨åç«¯ï¼Œè¿œç¨‹è°ƒç”¨å‘ç”Ÿåœ¨è¿™é‡Œï¼‰
[æœ€åå†…éƒ¨çŠ¶æ€ `self.state` è¢«è®¾ç½®ä¸º `State::Read(r)`ï¼Œå¹¶å†æ¬¡è°ƒç”¨ `self.poll_read()`](focus://57:58)ã€‚
[å†æ¬¡è°ƒç”¨ `self.poll_read()` åï¼Œ`RangeReader` å†…éƒ¨çŠ¶æ€è¢«è®¾ç½®ä¸º `State::Reader(R)`](focus://60:73)ã€‚
[è¿™é‡Œçš„ `R(r)` ä¾¿æ˜¯è¯»å–è¯·æ±‚å“åº”çš„å­—èŠ‚æµï¼Œå¯¹äº S3 å­˜å‚¨åç«¯ï¼Œ`Pin::new(r).poll_read(cx, buf)` å°† TCP ç¼“å†²åŒºçš„å­—èŠ‚æ•°æ®å†™å…¥åˆ°ä¸Šå±‚åº”ç”¨ä¸­](focus://60)ã€‚

```rust core/src/raw/oio/read/range_read.rs focus=43:73
impl<A, R> oio::Read for RangeReader<A, R>
where
    A: Accessor<Reader = R>,
    R: oio::Read,
{
    fn poll_read(&mut self, cx: &mut Context<'_>, buf: &mut [u8]) -> Poll<Result<usize>> {
        // Sanity check for normal cases.
        if buf.is_empty() || self.cur >= self.size.unwrap_or(u64::MAX) {
            return Poll::Ready(Ok(0));
        }

        match &mut self.state {
            State::Idle => {
                self.state = if self.offset.is_none() {
                    // Offset is none means we are doing tailing reading.
                    // we should stat first to get the correct offset.
                    State::SendStat(self.stat_future())
                } else {
                    State::SendRead(self.read_future())
                };

                self.poll_read(cx, buf)
            }
            State::SendStat(fut) => {
                let rp = ready!(Pin::new(fut).poll(cx)).map_err(|err| {
                    // If stat future returns an error, we should reset
                    // state to Idle so that we can retry it.
                    self.state = State::Idle;
                    err
                })?;

                let length = rp.into_metadata().content_length();
                self.fill_range(length).map_err(|err| {
                    // If stat future returns an error, we should reset
                    // state to Idle so that we can retry it.
                    self.state = State::Idle;
                    err
                })?;

                self.state = State::Idle;
                self.poll_read(cx, buf)
            }
            State::SendRead(fut) => {
                let (rp, r) = ready!(Pin::new(fut).poll(cx)).map_err(|err| {
                    // If read future returns an error, we should reset
                    // state to Idle so that we can retry it.
                    self.state = State::Idle;
                    err
                })?;

                // Set size if read returns size hint.
                if let Some(size) = rp.size() {
                    if size != 0 && self.size.is_none() {
                        self.size = Some(size + self.cur);
                    }
                }
                self.state = State::Read(r);
                self.poll_read(cx, buf)
            }
            State::Read(r) => match ready!(Pin::new(r).poll_read(cx, buf)) {
                Ok(0) => {
                    // Reset state to Idle after all data has been consumed.
                    self.state = State::Idle;
                    Poll::Ready(Ok(0))
                }
                Ok(n) => {
                    self.cur += n as u64;
                    Poll::Ready(Ok(n))
                }
                Err(e) => {
                    self.state = State::Idle;
                    Poll::Ready(Err(e))
                }
            },
        }
    }
}
```

---
### æœ€åçœ‹ä¸‹ `self.poll_seek()` 

[è¿˜è®°å¾—åˆšæ‰æˆ‘ä»¬ `RangeReader` å†…éƒ¨çŠ¶æ€å—ï¼Ÿæ²¡é”™ï¼Œæ˜¯`State::Reader(R)`](focus://49:53)ã€‚
å¦‚æœæˆ‘ä»¬åœ¨ `read` ä¹‹ååœ¨è°ƒç”¨ `seek`ï¼Œ[`RangeReader` å†…éƒ¨çš„å­—èŠ‚æµä¼šè¢«ä¸¢å¼ƒï¼ŒçŠ¶æ€é‡æ–°è®¾ç½®ä¸º `State::Idle`](focus://52)ã€‚
ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨æ¯æ¬¡ `seek` è°ƒç”¨åå†æ¬¡è°ƒç”¨ `read`ï¼Œ`RangeReader` ä¾¿ä¼šè¯·æ±‚åº•å±‚ `Accessor` çš„ `read` æ¥å£(`acc.read(&path, op).await`) 
å‘èµ·ä¸€ä¸ªè¿œç¨‹è°ƒç”¨ï¼Œè¿”å›ä¸€ä¸ªåŒ…å« `[Pos, size)` çš„ `Reader`ï¼›ç„¶è€Œå¯¹äº S3 å­˜å‚¨åç«¯ï¼Œè°ƒç”¨è¿™ä¸ªæ¥å£çš„å¼€é”€æ˜¯éå¸¸æ˜‚è´µçš„ï¼ˆTTFB é€šå¸¸é«˜è¾¾ç™¾æ¯«ç§’ï¼‰ã€‚

å¦å¤–è¿˜æœ‰ä¸€ä¸ªæ€§èƒ½ç›¸å…³çš„é‡ç‚¹ï¼Œ[å½“æˆ‘ä»¬å°è¯• `SeekFrom::End()` çš„æ—¶ï¼Œä¸” `self.size` æœªçŸ¥æ—¶ï¼Œä¼šæœ‰ä¸€æ¬¡é¢å¤–çš„ `stat` æ“ä½œ](focus://15:18)ã€‚
[`self.poll_seek()` è°ƒç”¨å `self.cur` ä¼šè¢«è®¾ç½®ä¸º `base.checked_add(amt)`](focus://22:33)ã€‚

```rust core/src/raw/oio/read/range_read.rs focus=7:53
impl<A, R> oio::Read for RangeReader<A, R>
where
    A: Accessor<Reader = R>,
    R: oio::Read,
{
    fn poll_seek(&mut self, cx: &mut Context<'_>, pos: SeekFrom) -> Poll<Result<u64>> {
        match &mut self.state {
            State::Idle => {
                let (base, amt) = match pos {
                    SeekFrom::Start(n) => (0, n as i64),
                    SeekFrom::Current(n) => (self.cur as i64, n),
                    SeekFrom::End(n) => {
                        if let Some(size) = self.size {
                            (size as i64, n)
                        } else {
                            self.state = State::SendStat(self.stat_future());
                            return self.poll_seek(cx, pos);
                        }
                    }
                };

                let seek_pos = match base.checked_add(amt) {
                    Some(n) if n >= 0 => n as u64,
                    _ => {
                        return Poll::Ready(Err(Error::new(
                            ErrorKind::InvalidInput,
                            "invalid seek to a negative or overflowing position",
                        )))
                    }
                };

                self.cur = seek_pos;
                Poll::Ready(Ok(self.cur))
            }
            State::SendStat(fut) => {
                let rp = ready!(Pin::new(fut).poll(cx)).map_err(|err| {
                    // If stat future returns an error, we should reset
                    // state to Idle so that we can retry it.
                    self.state = State::Idle;
                    err
                })?;

                let length = rp.into_metadata().content_length();
                self.fill_range(length)?;

                self.state = State::Idle;
                self.poll_seek(cx, pos)
            }
            State::SendRead(_) => {
                // It's impossible for us to go into this state while
                // poll_seek. We can just drop this future and check state.
                self.state = State::Idle;
                self.poll_seek(cx, pos)
            }
            State::Read(_) => {
                // There is an optimization here that we can calculate if users trying to seek
                // the same position, for example, `reader.seek(SeekFrom::Current(0))`.
                // In this case, we can just return current position without dropping reader.
                if pos == SeekFrom::Current(0) || pos == SeekFrom::Start(self.cur) {
                    return Poll::Ready(Ok(self.cur));
                }

                self.state = State::Idle;
                self.poll_seek(cx, pos)
            }
        }
    }
}
```

</CH.Scrollycoding>

## åç»­
[RFC](https://github.com/apache/incubator-opendal/pull/3734) ä¼šä¸º CompleteLayer Reader å¼•å…¥ä¸€ä¸ª `Buffer`ï¼Œç¼“è§£é¢‘ç¹ IO ï¼ˆä»¥åŠè¿œç¨‹è°ƒç”¨ï¼‰å¸¦æ¥çš„å¼€é”€ã€‚
```rust
  let reader = op.reader_with("path").buffer(32 * 1024 * 1024).await;
```
æœ€åï¼ŒReader ä¼šæ”¯æŒå¹¶è¡ŒåŠ è½½æ•°æ®ï¼Œä¸»è¦æ˜¯é’ˆå¯¹ S3 è¿™ç±»å­˜å‚¨åç«¯çš„ä¼˜åŒ–ã€‚
```rust
  let reader = op.reader_with("path").buffer(32 * 1024 * 1024).concurrent(4).await;
```
